## 协程

C++ 20 协程是一个无栈（stackless）的协程，同时，C++ 20 协程是非对称的协程

**“无栈”**这个名字有点容易让人误解。它不是说协程没有调用栈，而是指协程本身的状态和数据不存储在传统的执行栈（execution stack）上。一个传统的、有栈的协程（Stackful Coroutine），比如 Boost.Context 或 Go 语言的 goroutine，会为自己分配一块完整、独立的内存空间作为调用栈。这个栈足够大，可以让你在这个协程里像写普通函数一样嵌套调用多层函数。每个协程都有自己的栈，互不干扰。

而 C++20 的无栈协程，它共享调用它的线程的栈。它的“状态”被存储在了堆（heap）上的一个独立对象（称为“协程状态/帧”，coroutine state/frame）里。

**“非对称”**指的是协程之间的调用/控制流关系是不对称的。协程之间存在一个明显的调用者和被调用者（resumer 和 resumee）的层级关系。

一个协程（Callee）只能将控制流返回（`co_await` 或 `co_return`） 到恢复（`resume`）它的那个协程（`Caller`）。你不能随意将控制权转移到某个任意其他的协程。

## 实现

C++的协程（协程函数）内部可以用 `co_await` , `co_yield` 两个关键字挂起协程，`co_return` 关键字进行返回。
