

## **OLTP VS. OLAP**

联机事务处理 (OLTP) 的工作负载的特点是：

- 短暂的读/写事务。通常事务运行在 50ms 以内，超过这个时间的事务我们就认为它是长时间运行的事务。

- 只涉及较少的数据。

- 重复操作。重复的 SQL 更方便进行查询优化

在线分析处理（OLAP）的工作负载的特点是：

- 长时间运行的只读查询。分析操作可能涉及表中几乎所有的数据。

- 复杂的连接。分析操作也可能涉及库中几乎所有的表。

- 探索性查询。每次数据分析的目的可能都不同，所以每次的 SQL 可能都不一样，所以难以进行 SQL 的定向优化。

因为两种系统的工作负载的不同，涉及分布式系统时的决策也会有所不同，本篇讨论分布式 OLTP 系统的设计。。

我们会在 Decentralized Coordinator 环境下讨论本节的内容。即：有一个应用程序和多个数据分区，这些分区之一被选为主节点，交易的开始请求从应用程序到主节点，查询将直接发送到各个节点。提交请求从应用程序服务器转到主节点，并且主节点负责收集所有参与节点的提交意见，如果所有参与的节点都同意可以安全地提交，那么我们可以 commit 交易。使用 2PL、MVCC、OCC 或其他策略来确定是否可以在每个节点上安全地进行交易。

<figure markdown="span">
    ![Image title](./22.png){ width="550" }
</figure>

以下各节将讨论如何确保所有节点都认同事务提交，如何确保所有节点在同意之后成功执行了提交，以及如果节点宕机/消息延迟/系统可能不会等待所有节点都同意的情况下如何处理。

首先假设所有节点都是可信任的，不会做出损害系统的行为。如果我们不能信任其它节点，就需要 Byzantine Fault Tolerant 协议来实现分布式事务，大部分分布式系统都不需要考虑这个问题，除了区块链，但没有人会在区块链上运行一个系统来处理事务。

我们将讨论：

- Replication

- Atomic Commit Protocols

- Consistency Issues (CAP)

- Federated Databases

<hr>

## **Replication**

DBMS 可以添加冗余节点来复制数据以提高可用性。复制的方式有两种：Primary-Replica 和 Multi-Primary。

在 Primary-Replica 中，对每个数据对象的更新操作都会被发送到主副本中，在主副本一般会通过 WAL 将修改传递到其他副本中(无需使用 atomic commit protocol)。如果不需要最新信息，则可以允许只读事务访问副本。如果主数据库出现故障，则举行选举以选择新的主数据库。

在 Multi-Primary 中，事务可以更新任何副本上的数据对象。副本必须使用原子提交协议相互同步。

<figure markdown="span">
    ![Image title](./23.png){ width="550" }
</figure>

### **K-Safety**

K-safty 指的是同步复制节点 (In-sync Replica) 数量与复制数据库的容错性的关系。通常如果同步复制节点小于 K 个，数据库就会停止接收新请求，直到同步复制节点的数量重新满足要求。K 的大小取决于你对数据丢失的容忍度。

### **Propagation Scheme**


当事务在复制的数据库上提交时，DBMS 决定是否必须等待该事务的更改传播到其他节点，然后才能将确认发送到应用程序客户端。有两个传播级别：Synchronous（强一致性）和 Asynchronous（最终一致性）。

<img src="../24.png" align="right" height="200" width="200">

在 Synchronous 方案中，主节点将更新发送到副本，然后等待它们确认它们已完全应用（即记录）更改。然后，主服务器可以通知客户端更新成功。它保证了 DBMS 不会因为强一致性而丢失任何数据。这在传统的 DBMS 中更为常见。

在 Asynchronous 方案中，主节点立即将确认返回给客户端，而无需等待副本应用更改。在此方法中，可能会出现过时的读取，因为在发生读取时，更新可能无法完全应用于副本。如果可以容忍一些数据丢失，则此选项可能是一种可行的优化。这在 NoSQL 系统中常用。


### **Propagation Timing**

主节点将日志同步给复制节点的时机。

- Continuous：对于连续传播计时，主副本在生成日志消息时立即发送日志消息到其他副本中。DBMS 还需要将事务提交或中止的信息也传播给复制节点，保证事务在复制节点也能统一提交或中止。缺点在于：如果事务最终中止，那么复制节点就做了无用功。大多数系统都使用此方法。

- On Commit：DBMS 只在一个事务彻底执行完成时才将日志传播给复制节点，这样如果事务中止，复制节点就什么事都不用做。缺点在于，由于需要等待事务结束时才同步数据，整体同步效率较低。

### **Active vs Passive**

主节点与复制节点执行事务的顺序。

- Active-Active：事务同时在多个复制节点上独立执行，在执行结束时需要检查两边数据是否一致。

- Active-Passive：事务先在一个复制节点上执行，然后将数据的变动传播给其它复制节点。大部分系统采用这种方式。

<hr>

## **Atomic Commit Protocols**

当多节点事务完成时，DBMS 需要询问所有涉及的节点是否可以安全地提交。根据协议，可能需要大多数节点或所有节点来提交。示例包括：


- Two-Phase Commit (1970s)

- Three-Phase Commit (1983)

- Viewstamped Replication (1988)

- Paxos (1989)

- ZAB (2008? Zookeeper Atomic Broadcast protocol, Apache Zookeeper)

- Raft (2013)

### **Two-Phase Commit**


### **Paxos**

<hr>

## **CAP Theorem**


